number:
  # Агрессивность. Регулирует, насколько быстро система реагирует на изменения
  # уровня CO2. Значение от 1 до 5:
  #   1: Медленная реакция
  #   3: Средняя скорость реакции (по-умолчанию)
  #   5: Быстрая реакция
  - platform: template
    id: tion_auto_aggressiveness
    name: Auto Aggressiveness
    optimistic: true
    min_value: 1
    max_value: 5
    step: 1
    initial_value: 3
    mode: slider
    entity_category: config
  # Минимальный интервал. Минимальное время (в минутах) между изменениями
  # скорости, чтобы избежать слишком частых переключений.
  - platform: template
    id: tion_auto_min_time_delta
    name: Auto Min Time Delta
    optimistic: true
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 10
    mode: box
    entity_category: config
    unit_of_measurement: min

# Если текущий уровень CO2 отклоняется от целевого значения (setpoint),
# рассчитывается новая целевая скорость (new_speed) на основе следующих
# параметров:
#   Целевая скорость:
#     * Отклонение от целевого уровня CO2:
#       Чем больше отклонение, тем выше должна быть целевая скорость.
#     * Агрессивность управления (aggressiveness):
#       Этот параметр определяет, насколько быстро система реагирует на
#       изменения уровня CO2. Высокое значение агрессивности приводит к
#       более быстрому увеличению скорости, а низкое — к более плавному
#       изменению.
#   Минимальный интервал между переключениями:
#     * Чтобы избежать слишком частых переключений скорости, алгоритм
#       учитывает минимальный интервал времени (min_time_delta) между
#       изменениями скорости.
#     * Если прошло меньше времени, чем указано в этом интервале, новая
#       целевая скорость игнорируется, даже если уровень CO2 изменился.
#   Плавное изменение скорости (Ramping):
#     * После определения новой целевой скорости (new_speed), текущая скорость
#       (cur_speed) не меняется резко, а постепенно приближается к целевой с
#       использованием шага изменения (ramp_step).
#     * Каждую итерацию скорость изменяется на значение ramp_step в направлении
#       целевой скорости:
#         Если текущая скорость ниже целевой, она увеличивается на ramp_step.
#         Если текущая скорость выше целевой, она уменьшается на ramp_step.
#     * Этот процесс продолжается до тех пор, пока текущая скорость не достигнет
#       целевой.
#     * На текущий момент ramp_step всегда равен 1
#   Ограничения скорости:
#     * Скорость вентилятора всегда ограничивается минимальным (min_speed) и
#       максимальным (max_speed) значениями, чтобы предотвратить некорректные
#       состояния.
#     * Даже если расчет показывает необходимость выхода за эти пределы,
#       скорость будет автоматически корректироваться до допустимого диапазона.
#   Приоритет минимальной скорости:
#     * Если уровень CO2 возвращается в пределы гистерезиса, алгоритм стремится
#       вернуть скорость вентилятора к минимальной (min_speed), даже если ранее
#       была установлена более высокая скорость.
tion:
  auto:
    lambda: |-
      // Текущие показания CO2
      const int co2_level = x;
      // Целевое значение CO2
      const int setpoint = id(tion_api).api()->get_auto_setpoint();
      // Агрессивность вентиляции
      const int aggressiveness = id(tion_auto_aggressiveness).state;
      // Минимальная скорость вентиляции
      const uint8_t min_speed = id(tion_api).api()->get_auto_min_fan_speed();
      // Максимальная скорость вентиляции
      const uint8_t max_speed = id(tion_api).api()->get_auto_max_fan_speed();
      // Текущая скорость вентиляции
      const uint8_t cur_speed = id(tion_api).api()->get_state().fan_speed;
      // Минимальное время переключения вентилятора в миллисекундах
      const uint32_t min_time_delta = uint32_t(id(tion_auto_min_time_delta).state) * 60000;
      // Доступное количество скоростей для изменения, полагаем что максимальная скорость всегда больше минимальной
      uint8_t spd_range = max_speed - min_speed;
      // Установка шага плавного изменения скорости
      constexpr uint8_t ramp_step = 1;

      #ifndef USE_ARDUINO
      auto constrain = [](auto&& amt, auto&& low, auto&& high) { return amt < low ? low : amt > high ? high : amt; };
      #endif

      // Если доступна только одна скорость, то только ей и оперируем
      if (spd_range == 1) {
          return min_speed;
      }

      // Время последнего обновления скорости
      static uint32_t last_update_time = 0;
      // Текущее время
      const uint32_t now = millis();

      // Если не было обновлений, например, старт esp, или случилось
      // переполнение, обновим время последнего обновления и выйдем,
      // лучше подождать чем лишний раз дергать вентилятор
      if (last_update_time == 0 || last_update_time > now) {
        last_update_time = now;
        return constrain(cur_speed, min_speed, max_speed);
      }

      // Расчет временного интервала
      uint32_t time_delta = now - last_update_time;

      // Если прошло меньше времени, то ничего не изменяем
      if (time_delta < min_time_delta) {
        return constrain(cur_speed, min_speed, max_speed);
      }

      // Новая скорость вентилятора, минимальная по-умолчанию
      uint8_t new_speed = min_speed;

      // Вычисление отклонения от целевого уровня CO2
      int deviation = co2_level - setpoint;

      // Изменяем скорость если есть отклонения в большую сторону
      if (deviation > 0) {
        // Рассчитываем корректировку скорости на основе отклонения и агрессивности
        uint8_t adj_factor = (uint8_t)((deviation / (float)setpoint) * aggressiveness * spd_range);

        uint8_t adj_speed = min_speed + adj_factor;

        // Применим расчетную скорость
        new_speed = adj_speed;
      }

      // Плавно изменяем текущую скорость
      new_speed = constrain(new_speed, cur_speed - ramp_step, cur_speed + ramp_step);

      // Ограничиваем скорость допустимым диапазоном
      new_speed = constrain(new_speed, min_speed, max_speed);

      // Если скорость изменилась, то обновим время последнего переключения
      if (cur_speed != new_speed) {
        last_update_time = now;
      }

      // Вернем новую скорость вентиляции
      return new_speed;

